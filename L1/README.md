# Содержание
- [Содержание](#содержание)
- [Задания](#задания)
- [Устные вопросы](#устные-вопросы)
  - [Ответы](#ответы)
    - [1. Какой самый эффективный способ конкатенации строк?](#1-какой-самый-эффективный-способ-конкатенации-строк)
    - [2. Что такое интерфейсы, как они применяются в Go?](#2-что-такое-интерфейсы-как-они-применяются-в-go)
      - [Что такое intrface:](#что-такое-intrface)
      - [Как применяются:](#как-применяются)
      - [Пустой интерфейс](#пустой-интерфейс)
    - [3. Чем отличаются RWMutex от Mutex?](#3-чем-отличаются-rwmutex-от-mutex)
    - [4. Чем отличаются буферизированные и не буферизированные каналы?](#4-чем-отличаются-буферизированные-и-не-буферизированные-каналы)
    - [5. Какой размер у структуры struct{}{}?](#5-какой-размер-у-структуры-struct)
    - [6. Есть ли в Go перегрузка методов или операторов?](#6-есть-ли-в-go-перегрузка-методов-или-операторов)
    - [7. В какой последовательности будут выведены элементы map[int]int?](#7-в-какой-последовательности-будут-выведены-элементы-mapintint)
    - [8. В чем разница make и new?](#8-в-чем-разница-make-и-new)
    - [9. Сколько существует способов задать переменную типа slice или map?](#9-сколько-существует-способов-задать-переменную-типа-slice-или-map)
      - [Map](#map)
      - [Slice](#slice)
    - [10. Что выведет данная программа и почему?](#10-что-выведет-данная-программа-и-почему)
    - [11. Что выведет данная программа и почему?](#11-что-выведет-данная-программа-и-почему)
    - [12. Что выведет данная программа и почему?](#12-что-выведет-данная-программа-и-почему)
    - [13. Что выведет данная программа и почему?](#13-что-выведет-данная-программа-и-почему)
    - [14. Что выведет данная программа и почему?](#14-что-выведет-данная-программа-и-почему)
# Задания
Решения задания можно найти в соответствующей папке.  
Например: Задание №21 можно посмотреть в папке [task21](Task21)

# Устные вопросы
## Ответы
### 1. Какой самый эффективный способ конкатенации строк?

```Golang
func concat(x,y string) string{
    var builder strings.Builder
    builder.Grow(len(x)+len(y))
    builder.WriteString(x)
    builder.WriteString(y)
    return builder.String()
}
```

### 2. Что такое интерфейсы, как они применяются в Go?
#### Что такое intrface:
>Interface - это type в Go. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа. 

<details>
<summary> Пример </summary>

```Golang
type Stringer interface {
    String() string
}
```

Это значит что этому интерфейсу подойдут типы у которых есть метод `String() string`

```Golang
type Book struct {
    Title string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}
```

:heavy_check_mark: Тип `Book` подойдет интерфейсу `Stringer`, т.к. у него есть метод `String() string`

```Golang
type Count int

func (c Count) String() {
    return fmt.Println(c)
}
```

:x: Тип `Count` уже не подойдет, т.к. метод не соответствует (не возвращает string).
</details>

>Когда вы видите в Go объявление (переменной, параметра функции или поля структуры), имеющее интерфейсный тип, вы можете использовать объект любого типа, пока он удовлетворяет интерфейсу.

#### Как применяются:

1. Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
2. Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
3. Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

####  Пустой интерфейс

Отдельно выделю такой тип как `interface{}`  
Это интерфейс которому удовлетворяет любой тип.

### 3. Чем отличаются RWMutex от Mutex?

`Mutex` - это блокировка взаимного исключения.

`RWMutex` - это блокировка взаимного исключения чтения/записи.

Отличия в том что `RWMutex` может отдельно блокировать запись в объект, позволяя параллельно читать из объекта.

###  4. Чем отличаются буферизированные и не буферизированные каналы?

Не буферизированный канал блокируется пока не получат данные из канала, а буферизированный заблокируется только когда заполнен будет буфер.

```Golang
// небуферизованный канал целых чисел
ci := make(chan int)

// небуферизованный канал целых чисел            
cj := make(chan int, 0)   
     
// буферизованный канал указателей на Files
cs := make(chan *os.File, 100)  
```

### 5. Какой размер у структуры struct{}{}?

Размер пустой структуры равен 0.

```Golang
fmt.Println(unsafe.Sizeof(struct{}{}))
```

Вывод:
```
0
```

### 6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям или использовать интерфейсы.

### 7. В какой последовательности будут выведены элементы map[int]int?

<details>
<summary> Пример </summary>

```Golang
m:=map[int]int{
    0: 1,
    1: 124,
    2: 281,
}
```
</details>

Смотря как итерироваться.

Если мы используем `range`, то в случайном порядке.  
```Golang
for idx, val := range {
    fmt.Println(idx,":",val)
}
```

А если так то в упорядоченном
```Golang
for i:=0;i<3;i++ {
    if val, ok := m[i]; ok {
        fmt.Println(i,":",val)
    }
}
```
Но 2 вариант возможен только если мы знаем индекс 1 значения и последнего.

### 8. В чем разница make и new?

||**make( )**|**new( )**|
|:----|:----|:----|
|1|Используется только для slice, map, chan|Любая структура, включая срез, карту, чан|
|2|Входящие параметры включают тип и размер.|	Допускается только один параметр типа, без размера|
|3|Возвращается сам тип|Возврат - это указатель типа|
|4|Выделить место в памяти и инициализировать|Выделить место в памяти без инициализации|

### 9. Сколько существует способов задать переменную типа slice или map?
#### Map
```Golang
var m map[int]int
```
Но так делать опасно, так мы не инициализировали его и при добавлении значений будут ошибки.

```Golang
m1:= make(map[int]int)

m2:= map[int]int{
    12: 123,
    123: 12,
    1: 1,
}
```
#### Slice
```Golang
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}
e:= make([]int,12,15)
```

### 10. Что выведет данная программа и почему?
```Golang
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    mt.Println(*p)
}
```

Выведет:
```
1
1
```

Так как функция update изменяет локальную копию указателя

### 11. Что выведет данная программа и почему?
```Golang
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

Произойдет deadlock потому что мы в горутину передаем копию wg.

### 12. Что выведет данная программа и почему?

```Golang
func main() {
    n := 0
    if true{
        n := 1
        n++
    }
    fmt.Println(n)
}
```

Вывод:
```
0
```
Т.к. в if мы создаем локальную переменную n.

### 13. Что выведет данная программа и почему?
```Golang
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```

Вывод:
```
[100 2 3 4 5]
```

Потому что аppend создаст указатель на новый слайс

### 14. Что выведет данная программа и почему?
```Golang
func main() {
	slice := []string{"a", "a"}
	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```
Вывод:
```
[b b a][a a]%
```

Потому что append создала указатель на новый слайс и функция меняла уже его.